package app

import (
	"strings"
	"testing"

	"bb-project/internal/domain"
)

func TestFixActionSpecsHaveCoreMetadata(t *testing.T) {
	t.Parallel()

	actions := []string{
		FixActionIgnore,
		FixActionAbortOperation,
		FixActionCreateProject,
		FixActionForkAndRetarget,
		FixActionSyncWithUpstream,
		FixActionPush,
		FixActionStageCommitPush,
		FixActionPublishNewBranch,
		FixActionCheckpointThenSync,
		FixActionPullFFOnly,
		FixActionSetUpstreamPush,
		FixActionEnableAutoPush,
	}

	for _, action := range actions {
		action := action
		t.Run(action, func(t *testing.T) {
			t.Parallel()

			spec, ok := fixActionSpecFor(action)
			if !ok {
				t.Fatalf("missing action spec for %q", action)
			}
			if strings.TrimSpace(spec.Label) == "" {
				t.Fatalf("spec label missing for %q", action)
			}
			if strings.TrimSpace(spec.Description) == "" {
				t.Fatalf("spec description missing for %q", action)
			}
			if spec.BuildPlan == nil {
				t.Fatalf("spec plan builder missing for %q", action)
			}
		})
	}
}

func TestFixActionRiskUsesSharedSpec(t *testing.T) {
	t.Parallel()

	tests := []struct {
		action string
		risky  bool
	}{
		{action: FixActionPush, risky: true},
		{action: FixActionStageCommitPush, risky: true},
		{action: FixActionPublishNewBranch, risky: true},
		{action: FixActionCheckpointThenSync, risky: true},
		{action: FixActionSyncWithUpstream, risky: true},
		{action: FixActionPullFFOnly, risky: false},
		{action: FixActionEnableAutoPush, risky: false},
		{action: "unknown-action", risky: false},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.action, func(t *testing.T) {
			t.Parallel()
			if got := isRiskyFixAction(tt.action); got != tt.risky {
				t.Fatalf("isRiskyFixAction(%q) = %t, want %t", tt.action, got, tt.risky)
			}
		})
	}
}

func TestFixActionPlanStageCommitPushIncludesCommandsAndEffects(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionStageCommitPush, fixActionPlanContext{
		Branch:               "main",
		Upstream:             "",
		OriginURL:            "git@github.com:you/api.git",
		CommitMessage:        "auto",
		GenerateGitignore:    true,
		GitignorePatterns:    []string{"node_modules/"},
		MissingRootGitignore: true,
	})

	if len(plan) < 4 {
		t.Fatalf("stage-commit-push plan entries = %d, want >= 4", len(plan))
	}
	if !planContains(plan, true, "git add -A") {
		t.Fatalf("expected add command in plan, got %#v", plan)
	}
	if !planContains(plan, true, "git commit -m") {
		t.Fatalf("expected commit command in plan, got %#v", plan)
	}
	if !planContains(plan, true, "git push -u") {
		t.Fatalf("expected upstream push command in plan, got %#v", plan)
	}
	if !planContains(plan, false, "Generate root .gitignore") {
		t.Fatalf("expected gitignore generation effect in plan, got %#v", plan)
	}
}

func TestFixActionPlanStageCommitPushAutoMessageUsesLumenWhenConfigured(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionStageCommitPush, fixActionPlanContext{
		Branch:                             "main",
		Upstream:                           "",
		OriginURL:                          "",
		CommitMessage:                      "auto",
		AutoGenerateCommitMessageWhenEmpty: true,
	})

	addIdx := planEntryIndex(plan, "stage-git-add")
	draftIdx := planEntryIndex(plan, "stage-lumen-draft")
	commitIdx := planEntryIndex(plan, "stage-git-commit")
	if addIdx < 0 || draftIdx < 0 || commitIdx < 0 {
		t.Fatalf("missing expected add/draft/commit steps, got %#v", plan)
	}
	if !(addIdx < draftIdx && draftIdx < commitIdx) {
		t.Fatalf("expected add->draft->commit order, got %#v", plan)
	}
	if !strings.Contains(plan[draftIdx].Summary, "lumen draft") {
		t.Fatalf("unexpected lumen draft summary = %q", plan[draftIdx].Summary)
	}
	if !strings.Contains(plan[commitIdx].Summary, "<generated by lumen>") {
		t.Fatalf("unexpected commit summary = %q", plan[commitIdx].Summary)
	}
}

func TestFixActionPlanCreateProjectIncludesGhAndMetadataWrite(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionCreateProject, fixActionPlanContext{
		Branch:                  "main",
		Upstream:                "",
		OriginURL:               "",
		GitHubOwner:             "acme",
		RemoteProtocol:          "https",
		RepoName:                "api",
		PreferredRemote:         "origin",
		CreateProjectName:       "api",
		CreateProjectVisibility: domain.VisibilityPublic,
		GenerateGitignore:       true,
		GitignorePatterns:       []string{"node_modules/"},
		MissingRootGitignore:    true,
	})

	if !planContains(plan, true, "gh repo create") {
		t.Fatalf("expected gh create command in plan, got %#v", plan)
	}
	if !planContains(plan, true, "git remote add origin") {
		t.Fatalf("expected origin add command in plan, got %#v", plan)
	}
	if !planContains(plan, true, "gh repo create acme/api --public") {
		t.Fatalf("expected concrete owner/repo in gh create command, got %#v", plan)
	}
	if !planContains(plan, true, "git remote add origin https://github.com/acme/api.git") {
		t.Fatalf("expected concrete origin url in remote add command, got %#v", plan)
	}
	if !planContains(plan, false, "Write/update repo metadata") {
		t.Fatalf("expected metadata write effect in plan, got %#v", plan)
	}
	if planContains(plan, false, ".gitignore") {
		t.Fatalf("did not expect gitignore side effects in create-project plan, got %#v", plan)
	}
}

func TestFixActionPlanForkAndRetargetWritesMetadataBeforeForcePush(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionForkAndRetarget, fixActionPlanContext{
		Branch:         "main",
		GitHubOwner:    "acme",
		OriginURL:      "git@github.com:oven-sh/bun.git",
		RemoteProtocol: "ssh",
	})

	setRemoteIdx := planEntryIndex(plan, "fork-set-remote")
	writeMetadataIdx := planEntryIndex(plan, "fork-write-metadata")
	pushIdx := planEntryIndex(plan, "fork-push-upstream")
	if setRemoteIdx < 0 || writeMetadataIdx < 0 || pushIdx < 0 {
		t.Fatalf("missing expected fork plan entries, got %#v", plan)
	}
	if !(setRemoteIdx < writeMetadataIdx && writeMetadataIdx < pushIdx) {
		t.Fatalf("expected metadata write between set-remote and push, got %#v", plan)
	}

	pushEntry := plan[pushIdx]
	if !pushEntry.Command {
		t.Fatalf("fork-push-upstream should be a command step, got %#v", pushEntry)
	}
	if !strings.Contains(pushEntry.Summary, "git push -u --force acme main") {
		t.Fatalf("expected force push summary in fork-push-upstream, got %#v", pushEntry)
	}
}

func TestFixActionPlanForkAndRetargetRendersConcreteForkCommands(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionForkAndRetarget, fixActionPlanContext{
		Branch:         "main",
		GitHubOwner:    "niieani",
		RemoteProtocol: "ssh",
		OriginURL:      "git@github.com:oven-sh/bun.git",
	})

	forkCmdIdx := planEntryIndex(plan, "fork-gh-fork")
	setRemoteIdx := planEntryIndex(plan, "fork-set-remote")
	if forkCmdIdx < 0 || setRemoteIdx < 0 {
		t.Fatalf("missing expected fork plan entries, got %#v", plan)
	}

	forkCmd := plan[forkCmdIdx].Summary
	if strings.Contains(forkCmd, "<source-owner>/<repo>") {
		t.Fatalf("expected concrete fork source in summary, got %q", forkCmd)
	}
	if !strings.Contains(forkCmd, "gh repo fork oven-sh/bun --remote=false --clone=false") {
		t.Fatalf("unexpected fork command summary = %q", forkCmd)
	}

	setRemoteCmd := plan[setRemoteIdx].Summary
	if strings.Contains(setRemoteCmd, "<fork-url>") {
		t.Fatalf("expected concrete fork url in summary, got %q", setRemoteCmd)
	}
	if !strings.Contains(setRemoteCmd, "git remote add niieani git@github.com:niieani/bun.git") {
		t.Fatalf("unexpected set-remote summary = %q", setRemoteCmd)
	}
}

func TestFixActionPlanForkAndRetargetWithPublishBranchAvoidsForcePush(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionForkAndRetarget, fixActionPlanContext{
		Branch:             "main",
		GitHubOwner:        "acme",
		RemoteProtocol:     "ssh",
		OriginURL:          "git@github.com:oven-sh/bun.git",
		ForkBranchRenameTo: "feature/acme-bun",
	})

	checkoutIdx := planEntryIndex(plan, "fork-checkout-new-branch")
	pushIdx := planEntryIndex(plan, "fork-push-upstream")
	if checkoutIdx < 0 || pushIdx < 0 {
		t.Fatalf("missing expected checkout/push entries, got %#v", plan)
	}
	if checkoutIdx > pushIdx {
		t.Fatalf("expected checkout before push, got %#v", plan)
	}

	checkoutEntry := plan[checkoutIdx]
	if !checkoutEntry.Command {
		t.Fatalf("fork-checkout-new-branch should be a command step, got %#v", checkoutEntry)
	}
	if !strings.Contains(checkoutEntry.Summary, "git checkout -b feature/acme-bun") {
		t.Fatalf("expected branch checkout summary, got %#v", checkoutEntry)
	}

	pushEntry := plan[pushIdx]
	if !pushEntry.Command {
		t.Fatalf("fork-push-upstream should be a command step, got %#v", pushEntry)
	}
	if !strings.Contains(pushEntry.Summary, "git push -u acme feature/acme-bun") {
		t.Fatalf("expected non-force push summary for renamed branch, got %#v", pushEntry)
	}
	if strings.Contains(pushEntry.Summary, "--force") {
		t.Fatalf("did not expect force push when branch rename is provided, got %#v", pushEntry)
	}
}

func TestFixActionPlanStageCommitPushWithPublishBranchChecksOutBeforeCommit(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionStageCommitPush, fixActionPlanContext{
		Branch:             "main",
		Upstream:           "origin/main",
		OriginURL:          "git@github.com:you/api.git",
		PreferredRemote:    "origin",
		CommitMessage:      "auto",
		ForkBranchRenameTo: "feature/safe-publish",
	})

	checkoutIdx := planEntryIndex(plan, "stage-checkout-new-branch")
	addIdx := planEntryIndex(plan, "stage-git-add")
	commitIdx := planEntryIndex(plan, "stage-git-commit")
	pushIdx := planEntryIndex(plan, "stage-push-set-upstream")
	if checkoutIdx < 0 || addIdx < 0 || commitIdx < 0 || pushIdx < 0 {
		t.Fatalf("missing expected stage checkout/add/commit/push steps, got %#v", plan)
	}
	if !(checkoutIdx < addIdx && addIdx < commitIdx && commitIdx < pushIdx) {
		t.Fatalf("expected checkout->add->commit->push order, got %#v", plan)
	}
	if !strings.Contains(plan[checkoutIdx].Summary, "git checkout -b feature/safe-publish") {
		t.Fatalf("unexpected stage checkout summary = %q", plan[checkoutIdx].Summary)
	}
	if !strings.Contains(plan[pushIdx].Summary, "git push -u origin feature/safe-publish") {
		t.Fatalf("unexpected stage publish summary = %q", plan[pushIdx].Summary)
	}
}

func TestFixActionPlanPublishNewBranchChecksOutBeforeCommitAndPushesTargetBranch(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionPublishNewBranch, fixActionPlanContext{
		Branch:             "main",
		Upstream:           "origin/main",
		OriginURL:          "git@github.com:you/api.git",
		PreferredRemote:    "origin",
		CommitMessage:      "auto",
		ForkBranchRenameTo: "feature/safe-publish",
	})

	checkoutIdx := planEntryIndex(plan, "publish-checkout-new-branch")
	addIdx := planEntryIndex(plan, "stage-git-add")
	commitIdx := planEntryIndex(plan, "stage-git-commit")
	pushIdx := planEntryIndex(plan, "publish-push-set-upstream")
	if checkoutIdx < 0 || addIdx < 0 || commitIdx < 0 || pushIdx < 0 {
		t.Fatalf("missing expected publish-new-branch plan entries, got %#v", plan)
	}
	if !(checkoutIdx < addIdx && addIdx < commitIdx && commitIdx < pushIdx) {
		t.Fatalf("expected checkout->add->commit->push order, got %#v", plan)
	}
	if !strings.Contains(plan[checkoutIdx].Summary, "git checkout -b feature/safe-publish") {
		t.Fatalf("unexpected checkout summary = %q", plan[checkoutIdx].Summary)
	}
	if !strings.Contains(plan[pushIdx].Summary, "git push -u origin feature/safe-publish") {
		t.Fatalf("unexpected push summary = %q", plan[pushIdx].Summary)
	}
}

func TestFixActionPlanPushWithPublishBranchChecksOutThenPushesNewBranch(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionPush, fixActionPlanContext{
		Branch:             "main",
		Upstream:           "origin/main",
		PreferredRemote:    "origin",
		ForkBranchRenameTo: "feature/safe-publish",
	})

	checkoutIdx := planEntryIndex(plan, "push-checkout-new-branch")
	pushIdx := planEntryIndex(plan, "push-main")
	if checkoutIdx < 0 || pushIdx < 0 {
		t.Fatalf("missing expected push checkout/push steps, got %#v", plan)
	}
	if checkoutIdx > pushIdx {
		t.Fatalf("expected checkout before push, got %#v", plan)
	}
	if !strings.Contains(plan[checkoutIdx].Summary, "git checkout -b feature/safe-publish") {
		t.Fatalf("unexpected push checkout summary = %q", plan[checkoutIdx].Summary)
	}
	if !strings.Contains(plan[pushIdx].Summary, "git push -u origin feature/safe-publish") {
		t.Fatalf("unexpected push publish summary = %q", plan[pushIdx].Summary)
	}
}

func TestFixActionExecutionPlanAppendsRevalidationStep(t *testing.T) {
	t.Parallel()

	plan := fixActionExecutionPlanFor(FixActionPush, fixActionPlanContext{
		Branch:    "main",
		Upstream:  "origin/main",
		OriginURL: "git@github.com:you/api.git",
	})

	if len(plan) < 2 {
		t.Fatalf("execution plan entries = %d, want >= 2", len(plan))
	}
	last := plan[len(plan)-1]
	if last.ID != fixActionPlanRevalidateStateID {
		t.Fatalf("last execution-plan step id = %q, want %q", last.ID, fixActionPlanRevalidateStateID)
	}
	if !strings.Contains(last.Summary, "Revalidate repository status") {
		t.Fatalf("unexpected last execution-plan summary = %q", last.Summary)
	}
}

func TestFixActionPlanSyncWithUpstreamUsesSelectedStrategy(t *testing.T) {
	t.Parallel()

	rebasePlan := fixActionPlanFor(FixActionSyncWithUpstream, fixActionPlanContext{
		Upstream:     "origin/main",
		SyncStrategy: FixSyncStrategyRebase,
	})
	if !planContains(rebasePlan, true, "git rebase origin/main") {
		t.Fatalf("expected rebase command in sync-with-upstream plan, got %#v", rebasePlan)
	}

	mergePlan := fixActionPlanFor(FixActionSyncWithUpstream, fixActionPlanContext{
		Upstream:     "origin/main",
		SyncStrategy: FixSyncStrategyMerge,
	})
	if !planContains(mergePlan, true, "git merge --no-edit origin/main") {
		t.Fatalf("expected merge command in sync-with-upstream plan, got %#v", mergePlan)
	}
}

func TestFixActionPlanCheckpointThenSyncIncludesCommitSyncAndPush(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionCheckpointThenSync, fixActionPlanContext{
		Branch:               "main",
		Upstream:             "origin/main",
		OriginURL:            "git@github.com:you/api.git",
		CommitMessage:        "auto",
		GenerateGitignore:    true,
		GitignorePatterns:    []string{"node_modules/"},
		MissingRootGitignore: true,
		SyncStrategy:         FixSyncStrategyRebase,
		FetchPrune:           true,
	})

	if !planContains(plan, true, "git add -A") {
		t.Fatalf("expected add command in checkpoint-then-sync plan, got %#v", plan)
	}
	if !planContains(plan, true, "git commit -m") {
		t.Fatalf("expected commit command in checkpoint-then-sync plan, got %#v", plan)
	}
	if !planContains(plan, true, "git rebase origin/main") {
		t.Fatalf("expected rebase command in checkpoint-then-sync plan, got %#v", plan)
	}
	if !planContains(plan, true, "git push") {
		t.Fatalf("expected push command in checkpoint-then-sync plan, got %#v", plan)
	}
	if planContains(plan, true, "git push -u") {
		t.Fatalf("did not expect set-upstream push command in checkpoint-then-sync plan, got %#v", plan)
	}
	if !planContains(plan, false, "Generate root .gitignore") {
		t.Fatalf("expected gitignore generation effect in checkpoint-then-sync plan, got %#v", plan)
	}
}

func TestFixActionPlanCheckpointThenSyncWithPublishBranchChecksOutBeforeCommit(t *testing.T) {
	t.Parallel()

	plan := fixActionPlanFor(FixActionCheckpointThenSync, fixActionPlanContext{
		Branch:             "main",
		Upstream:           "origin/main",
		OriginURL:          "git@github.com:you/api.git",
		CommitMessage:      "auto",
		PreferredRemote:    "origin",
		ForkBranchRenameTo: "test-branch",
		SyncStrategy:       FixSyncStrategyRebase,
		FetchPrune:         true,
	})

	if idx := planEntryIndex(plan, "checkpoint-rename-branch"); idx >= 0 {
		t.Fatalf("did not expect publish branch rename in checkpoint-then-sync plan, got %#v", plan)
	}
	checkoutIdx := planEntryIndex(plan, "checkpoint-checkout-new-branch")
	addIdx := planEntryIndex(plan, "stage-git-add")
	commitIdx := planEntryIndex(plan, "stage-git-commit")
	pushIdx := planEntryIndex(plan, "checkpoint-push")
	if checkoutIdx < 0 || addIdx < 0 || commitIdx < 0 || pushIdx < 0 {
		t.Fatalf("missing expected checkpoint checkout/add/commit/push entries, got %#v", plan)
	}
	if !(checkoutIdx < addIdx && addIdx < commitIdx && commitIdx < pushIdx) {
		t.Fatalf("expected checkout->add->commit order before checkpoint push, got %#v", plan)
	}
	if !strings.Contains(plan[checkoutIdx].Summary, "git checkout -b test-branch") {
		t.Fatalf("unexpected checkpoint checkout summary = %q", plan[checkoutIdx].Summary)
	}
	if !strings.Contains(plan[pushIdx].Summary, "git push -u origin test-branch") {
		t.Fatalf("unexpected checkpoint push summary = %q", plan[pushIdx].Summary)
	}
}

func TestFixActionPlanSyncAndPullFetchPrunePreviewFollowsConfig(t *testing.T) {
	t.Parallel()

	syncEnabled := fixActionPlanFor(FixActionSyncWithUpstream, fixActionPlanContext{
		Upstream:     "origin/main",
		SyncStrategy: FixSyncStrategyRebase,
		FetchPrune:   true,
	})
	if !planContains(syncEnabled, true, "git fetch --prune") {
		t.Fatalf("expected fetch --prune command when enabled, got %#v", syncEnabled)
	}

	syncDisabled := fixActionPlanFor(FixActionSyncWithUpstream, fixActionPlanContext{
		Upstream:     "origin/main",
		SyncStrategy: FixSyncStrategyRebase,
		FetchPrune:   false,
	})
	if planContains(syncDisabled, true, "git fetch --prune") {
		t.Fatalf("did not expect fetch --prune command when disabled, got %#v", syncDisabled)
	}

	pullEnabled := fixActionPlanFor(FixActionPullFFOnly, fixActionPlanContext{FetchPrune: true})
	if !planContains(pullEnabled, true, "git fetch --prune") {
		t.Fatalf("expected pull fetch --prune command when enabled, got %#v", pullEnabled)
	}

	pullDisabled := fixActionPlanFor(FixActionPullFFOnly, fixActionPlanContext{FetchPrune: false})
	if planContains(pullDisabled, true, "git fetch --prune") {
		t.Fatalf("did not expect pull fetch --prune command when disabled, got %#v", pullDisabled)
	}
}

func TestFixActionPlanCommandSummariesAreConcreteCommands(t *testing.T) {
	t.Parallel()

	check := func(action string, plan []fixActionPlanEntry) {
		t.Helper()
		for _, entry := range plan {
			if !entry.Command {
				continue
			}
			summary := strings.TrimSpace(entry.Summary)
			if summary == "" {
				t.Fatalf("%s/%s has empty command summary", action, entry.ID)
			}
			if strings.Contains(summary, "<") || strings.Contains(summary, ">") {
				t.Fatalf("%s/%s contains placeholder delimiters: %q", action, entry.ID, summary)
			}
			if strings.Contains(summary, "(if ") || strings.Contains(summary, "(when ") {
				t.Fatalf("%s/%s contains conditional prose: %q", action, entry.ID, summary)
			}
		}
	}

	check(FixActionAbortOperation, fixActionPlanFor(FixActionAbortOperation, fixActionPlanContext{
		Operation: domain.OperationMerge,
	}))
	check(FixActionPush, fixActionPlanFor(FixActionPush, fixActionPlanContext{}))
	check(FixActionSyncWithUpstream, fixActionPlanFor(FixActionSyncWithUpstream, fixActionPlanContext{
		Upstream:     "origin/main",
		SyncStrategy: FixSyncStrategyRebase,
		FetchPrune:   true,
	}))
	check(FixActionStageCommitPush, fixActionPlanFor(FixActionStageCommitPush, fixActionPlanContext{
		Branch:        "main",
		Upstream:      "",
		OriginURL:     "git@github.com:you/api.git",
		CommitMessage: "auto",
	}))
	check(FixActionCheckpointThenSync, fixActionPlanFor(FixActionCheckpointThenSync, fixActionPlanContext{
		Branch:        "main",
		Upstream:      "origin/main",
		OriginURL:     "git@github.com:you/api.git",
		CommitMessage: "auto",
		SyncStrategy:  FixSyncStrategyRebase,
		FetchPrune:    true,
	}))
	check(FixActionPullFFOnly, fixActionPlanFor(FixActionPullFFOnly, fixActionPlanContext{
		FetchPrune: true,
	}))
	check(FixActionSetUpstreamPush, fixActionPlanFor(FixActionSetUpstreamPush, fixActionPlanContext{
		Branch:   "main",
		Upstream: "",
	}))
	check(FixActionCreateProject, fixActionPlanFor(FixActionCreateProject, fixActionPlanContext{
		Branch:                  "main",
		Upstream:                "",
		HeadSHA:                 "abc123",
		OriginURL:               "",
		GitHubOwner:             "acme",
		RemoteProtocol:          "https",
		RepoName:                "api",
		PreferredRemote:         "origin",
		CreateProjectName:       "api",
		CreateProjectVisibility: domain.VisibilityPublic,
	}))
	check(FixActionForkAndRetarget, fixActionPlanFor(FixActionForkAndRetarget, fixActionPlanContext{
		Branch:           "main",
		GitHubOwner:      "acme",
		RemoteProtocol:   "ssh",
		OriginURL:        "git@github.com:oven-sh/bun.git",
		ForkRemoteExists: false,
	}))
}

func planContains(plan []fixActionPlanEntry, command bool, fragment string) bool {
	for _, entry := range plan {
		if entry.Command != command {
			continue
		}
		if strings.Contains(entry.Summary, fragment) {
			return true
		}
	}
	return false
}

func planEntryIndex(plan []fixActionPlanEntry, id string) int {
	for i, entry := range plan {
		if entry.ID == id {
			return i
		}
	}
	return -1
}
