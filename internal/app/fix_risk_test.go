package app

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"bb-project/internal/gitx"
)

func TestCollectFixRiskSnapshotDetectsSecretAndNoisyChanges(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	runner := gitx.Runner{}
	if _, err := runner.RunGit(repo, "init", "-b", "main"); err != nil {
		t.Fatalf("git init failed: %v", err)
	}

	if err := os.MkdirAll(filepath.Join(repo, "node_modules", "left-pad"), 0o755); err != nil {
		t.Fatalf("mkdir node_modules: %v", err)
	}
	if err := os.WriteFile(filepath.Join(repo, "node_modules", "left-pad", "index.js"), []byte("module.exports = 1\n"), 0o644); err != nil {
		t.Fatalf("write node_modules file: %v", err)
	}
	if err := os.WriteFile(filepath.Join(repo, ".env"), []byte("TOKEN=secret\n"), 0o644); err != nil {
		t.Fatalf("write .env: %v", err)
	}

	risk, err := collectFixRiskSnapshot(repo, runner)
	if err != nil {
		t.Fatalf("collectFixRiskSnapshot failed: %v", err)
	}
	if !risk.MissingRootGitignore {
		t.Fatal("expected missing root .gitignore to be detected")
	}
	if len(risk.SecretLikeChangedPaths) == 0 || risk.SecretLikeChangedPaths[0] != ".env" {
		t.Fatalf("secret-like paths = %v, want .env", risk.SecretLikeChangedPaths)
	}
	if len(risk.NoisyChangedPaths) == 0 {
		t.Fatalf("expected noisy changed path, got: %v", risk.NoisyChangedPaths)
	}
	if !containsString(risk.SuggestedGitignorePatterns, "node_modules/") {
		t.Fatalf("suggested patterns = %v, want node_modules/", risk.SuggestedGitignorePatterns)
	}
}

func TestWriteGeneratedGitignoreCreatesMinimalSortedFile(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	err := writeGeneratedGitignore(repo, []string{"dist/", "node_modules/", "dist/"})
	if err != nil {
		t.Fatalf("writeGeneratedGitignore failed: %v", err)
	}

	raw, err := os.ReadFile(filepath.Join(repo, ".gitignore"))
	if err != nil {
		t.Fatalf("read .gitignore failed: %v", err)
	}
	got := string(raw)
	if !strings.Contains(got, "# Generated by bb fix") {
		t.Fatalf("missing generated header, got:\n%s", got)
	}
	if !strings.Contains(got, "dist/") || !strings.Contains(got, "node_modules/") {
		t.Fatalf("missing expected patterns, got:\n%s", got)
	}
	if strings.Count(got, "dist/") != 1 {
		t.Fatalf("expected deduped dist entry, got:\n%s", got)
	}
}

func TestWriteGeneratedGitignoreDoesNotOverrideExistingFile(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	gitignorePath := filepath.Join(repo, ".gitignore")
	if err := os.WriteFile(gitignorePath, []byte("custom\n"), 0o644); err != nil {
		t.Fatalf("seed .gitignore failed: %v", err)
	}
	if err := writeGeneratedGitignore(repo, []string{"node_modules/"}); err != nil {
		t.Fatalf("writeGeneratedGitignore failed: %v", err)
	}

	raw, err := os.ReadFile(gitignorePath)
	if err != nil {
		t.Fatalf("read .gitignore failed: %v", err)
	}
	if string(raw) != "custom\n" {
		t.Fatalf("expected existing .gitignore to be preserved, got:\n%s", string(raw))
	}
}

func containsString(values []string, want string) bool {
	for _, value := range values {
		if value == want {
			return true
		}
	}
	return false
}
