package app

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"bb-project/internal/gitx"
)

func TestCollectFixRiskSnapshotDetectsSecretAndNoisyChanges(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	runner := gitx.Runner{}
	if _, err := runner.RunGit(repo, "init", "-b", "main"); err != nil {
		t.Fatalf("git init failed: %v", err)
	}

	if err := os.MkdirAll(filepath.Join(repo, "node_modules", "left-pad"), 0o755); err != nil {
		t.Fatalf("mkdir node_modules: %v", err)
	}
	if err := os.WriteFile(filepath.Join(repo, "node_modules", "left-pad", "index.js"), []byte("module.exports = 1\n"), 0o644); err != nil {
		t.Fatalf("write node_modules file: %v", err)
	}
	if err := os.WriteFile(filepath.Join(repo, ".env"), []byte("TOKEN=secret\n"), 0o644); err != nil {
		t.Fatalf("write .env: %v", err)
	}

	risk, err := collectFixRiskSnapshot(repo, runner)
	if err != nil {
		t.Fatalf("collectFixRiskSnapshot failed: %v", err)
	}
	if !risk.MissingRootGitignore {
		t.Fatal("expected missing root .gitignore to be detected")
	}
	if len(risk.SecretLikeChangedPaths) == 0 || risk.SecretLikeChangedPaths[0] != ".env" {
		t.Fatalf("secret-like paths = %v, want .env", risk.SecretLikeChangedPaths)
	}
	if len(risk.NoisyChangedPaths) == 0 {
		t.Fatalf("expected noisy changed path, got: %v", risk.NoisyChangedPaths)
	}
	if !containsString(risk.SuggestedGitignorePatterns, "node_modules/") {
		t.Fatalf("suggested patterns = %v, want node_modules/", risk.SuggestedGitignorePatterns)
	}
}

func TestParseGitStatusPorcelainPreservesLeadingSpaceOnFirstLine(t *testing.T) {
	t.Parallel()

	raw := " M README.md\n M package.json\n"
	entries := parseGitStatusPorcelain(raw)
	if len(entries) != 2 {
		t.Fatalf("entries len = %d, want 2 (%v)", len(entries), entries)
	}
	if got := entries[0].Path; got != "README.md" {
		t.Fatalf("first path = %q, want README.md", got)
	}
}

func TestCollectFixRiskSnapshotKeepsFirstFilePathAndNumstat(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	runner := gitx.Runner{}
	if _, err := runner.RunGit(repo, "init", "-b", "main"); err != nil {
		t.Fatalf("git init failed: %v", err)
	}

	if err := os.WriteFile(filepath.Join(repo, "README.md"), []byte("line1\nline2\n"), 0o644); err != nil {
		t.Fatalf("seed README.md failed: %v", err)
	}
	if err := os.WriteFile(filepath.Join(repo, "package.json"), []byte("{\"name\":\"x\"}\n"), 0o644); err != nil {
		t.Fatalf("seed package.json failed: %v", err)
	}
	if _, err := runner.RunGit(repo, "add", "."); err != nil {
		t.Fatalf("git add failed: %v", err)
	}
	if _, err := runner.RunGit(
		repo,
		"-c", "user.name=bb",
		"-c", "user.email=bb@example.invalid",
		"commit", "-m", "init",
	); err != nil {
		t.Fatalf("git commit failed: %v", err)
	}

	if err := os.WriteFile(filepath.Join(repo, "README.md"), []byte("line1\nline2 updated\nline3\n"), 0o644); err != nil {
		t.Fatalf("update README.md failed: %v", err)
	}
	if err := os.WriteFile(filepath.Join(repo, "package.json"), []byte("{\"name\":\"x\",\"v\":1}\n"), 0o644); err != nil {
		t.Fatalf("update package.json failed: %v", err)
	}

	risk, err := collectFixRiskSnapshot(repo, runner)
	if err != nil {
		t.Fatalf("collectFixRiskSnapshot failed: %v", err)
	}

	readme, ok := changedFileByPath(risk.ChangedFiles, "README.md")
	if !ok {
		t.Fatalf("README.md missing from changed files: %#v", risk.ChangedFiles)
	}
	if readme.Added == 0 && readme.Deleted == 0 {
		t.Fatalf("README.md numstat should not be zero: %#v", readme)
	}
}

func TestWriteGeneratedGitignoreCreatesMinimalSortedFile(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	err := writeGeneratedGitignore(repo, []string{"dist/", "node_modules/", "dist/"})
	if err != nil {
		t.Fatalf("writeGeneratedGitignore failed: %v", err)
	}

	raw, err := os.ReadFile(filepath.Join(repo, ".gitignore"))
	if err != nil {
		t.Fatalf("read .gitignore failed: %v", err)
	}
	got := string(raw)
	if !strings.Contains(got, "# Generated by bb fix") {
		t.Fatalf("missing generated header, got:\n%s", got)
	}
	if !strings.Contains(got, "dist/") || !strings.Contains(got, "node_modules/") {
		t.Fatalf("missing expected patterns, got:\n%s", got)
	}
	if strings.Count(got, "dist/") != 1 {
		t.Fatalf("expected deduped dist entry, got:\n%s", got)
	}
}

func TestWriteGeneratedGitignoreDoesNotOverrideExistingFile(t *testing.T) {
	t.Parallel()

	repo := t.TempDir()
	gitignorePath := filepath.Join(repo, ".gitignore")
	if err := os.WriteFile(gitignorePath, []byte("custom\n"), 0o644); err != nil {
		t.Fatalf("seed .gitignore failed: %v", err)
	}
	if err := writeGeneratedGitignore(repo, []string{"node_modules/"}); err != nil {
		t.Fatalf("writeGeneratedGitignore failed: %v", err)
	}

	raw, err := os.ReadFile(gitignorePath)
	if err != nil {
		t.Fatalf("read .gitignore failed: %v", err)
	}
	if string(raw) != "custom\n" {
		t.Fatalf("expected existing .gitignore to be preserved, got:\n%s", string(raw))
	}
}

func containsString(values []string, want string) bool {
	for _, value := range values {
		if value == want {
			return true
		}
	}
	return false
}

func changedFileByPath(files []fixChangedFile, path string) (fixChangedFile, bool) {
	for _, file := range files {
		if file.Path == path {
			return file, true
		}
	}
	return fixChangedFile{}, false
}
