package app

import (
	"errors"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"bb-project/internal/domain"
	"bb-project/internal/state"
)

func TestRunDiffAndOperatePassThroughToLumen(t *testing.T) {
	t.Parallel()

	app, _, repoPath := newLumenTestApp(t)
	app.LookPath = func(file string) (string, error) {
		if file != "lumen" {
			t.Fatalf("lookPath file = %q, want lumen", file)
		}
		return "/usr/local/bin/lumen", nil
	}

	var gotDir string
	var gotName string
	var gotArgs []string
	app.RunCommandAttached = func(dir string, name string, args ...string) error {
		gotDir = dir
		gotName = name
		gotArgs = append([]string(nil), args...)
		return nil
	}

	code, err := app.runDiff("api", []string{"--watch", "--focus", "pkg/"})
	if err != nil {
		t.Fatalf("runDiff error: %v", err)
	}
	if code != 0 {
		t.Fatalf("runDiff code = %d, want 0", code)
	}
	if gotDir != repoPath {
		t.Fatalf("runDiff dir = %q, want %q", gotDir, repoPath)
	}
	if gotName != "/usr/local/bin/lumen" {
		t.Fatalf("runDiff binary = %q, want %q", gotName, "/usr/local/bin/lumen")
	}
	if got := strings.Join(gotArgs, " "); got != "diff --watch --focus pkg/" {
		t.Fatalf("runDiff args = %q, want %q", got, "diff --watch --focus pkg/")
	}

	gotDir = ""
	gotName = ""
	gotArgs = nil
	code, err = app.runOperate("api", []string{"--model", "gpt-5", "apply formatting"})
	if err != nil {
		t.Fatalf("runOperate error: %v", err)
	}
	if code != 0 {
		t.Fatalf("runOperate code = %d, want 0", code)
	}
	if gotDir != repoPath {
		t.Fatalf("runOperate dir = %q, want %q", gotDir, repoPath)
	}
	if gotName != "/usr/local/bin/lumen" {
		t.Fatalf("runOperate binary = %q, want %q", gotName, "/usr/local/bin/lumen")
	}
	if got := strings.Join(gotArgs, " "); got != "operate --model gpt-5 apply formatting" {
		t.Fatalf("runOperate args = %q, want %q", got, "operate --model gpt-5 apply formatting")
	}
}

func TestRunDiffLumenUnavailableShowsTipByDefault(t *testing.T) {
	t.Parallel()

	app, _, _ := newLumenTestApp(t)
	app.LookPath = func(file string) (string, error) {
		return "", errors.New("not found")
	}

	code, err := app.runDiff("api", nil)
	if code != 2 {
		t.Fatalf("runDiff code = %d, want 2", code)
	}
	if err == nil {
		t.Fatal("expected runDiff error when lumen is unavailable")
	}
	if !strings.Contains(err.Error(), "install lumen") {
		t.Fatalf("expected install tip in error, got %q", err)
	}
	if !strings.Contains(err.Error(), "show_install_tip=false") {
		t.Fatalf("expected tip-disable hint in error, got %q", err)
	}
}

func TestRunDiffLumenUnavailableHidesTipWhenDisabled(t *testing.T) {
	t.Parallel()

	app, paths, _ := newLumenTestApp(t)
	cfg, err := state.LoadConfig(paths)
	if err != nil {
		t.Fatalf("load config: %v", err)
	}
	cfg.Integrations.Lumen.ShowInstallTip = false
	if err := state.SaveConfig(paths, cfg); err != nil {
		t.Fatalf("save config: %v", err)
	}
	app.LookPath = func(file string) (string, error) {
		return "", errors.New("not found")
	}

	code, err := app.runDiff("api", nil)
	if code != 2 {
		t.Fatalf("runDiff code = %d, want 2", code)
	}
	if err == nil {
		t.Fatal("expected runDiff error when lumen is unavailable")
	}
	if strings.Contains(err.Error(), "install lumen") {
		t.Fatalf("expected install tip hidden, got %q", err)
	}
}

func TestGenerateLumenCommitMessageRestoresGitIndex(t *testing.T) {
	t.Parallel()

	app, _, repoPath := newLumenTestApp(t)
	app.LookPath = func(file string) (string, error) {
		return "/usr/local/bin/lumen", nil
	}
	app.RunCommandInDir = func(dir string, name string, args ...string) (string, error) {
		if dir != repoPath {
			t.Fatalf("draft dir = %q, want %q", dir, repoPath)
		}
		if name != "/usr/local/bin/lumen" {
			t.Fatalf("draft binary = %q, want %q", name, "/usr/local/bin/lumen")
		}
		if len(args) != 1 || args[0] != "draft" {
			t.Fatalf("draft args = %v, want [draft]", args)
		}
		return "feat: generated by lumen\n", nil
	}

	if err := os.WriteFile(filepath.Join(repoPath, "generated.txt"), []byte("new file\n"), 0o644); err != nil {
		t.Fatalf("write test file: %v", err)
	}

	message, err := app.generateLumenCommitMessage(repoPath)
	if err != nil {
		t.Fatalf("generateLumenCommitMessage error: %v", err)
	}
	if message != "feat: generated by lumen" {
		t.Fatalf("generated message = %q, want %q", message, "feat: generated by lumen")
	}

	statusOut, err := app.Git.RunGit(repoPath, "status", "--porcelain")
	if err != nil {
		t.Fatalf("git status failed: %v", err)
	}
	if !strings.Contains(statusOut, "?? generated.txt") {
		t.Fatalf("expected file to remain unstaged after draft generation, status=%q", statusOut)
	}
}

func TestRunFixAIMessageValidation(t *testing.T) {
	t.Parallel()

	app, _, _ := newLumenTestApp(t)

	code, err := app.runFix(FixOptions{
		Project:   "api",
		Action:    FixActionPush,
		AIMessage: true,
	})
	if code != 2 {
		t.Fatalf("runFix code = %d, want 2", code)
	}
	if err == nil {
		t.Fatal("expected runFix validation error")
	}
	if !strings.Contains(err.Error(), "--ai-message is only supported") {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestRunFixUsesLumenMessageWhenConfigDefaultEnabledAndMessageEmpty(t *testing.T) {
	t.Parallel()

	app, paths, repoPath := newLumenTestApp(t)
	cfg, err := state.LoadConfig(paths)
	if err != nil {
		t.Fatalf("load config: %v", err)
	}
	cfg.Integrations.Lumen.AutoGenerateCommitMessageWhenEmpty = true
	if err := state.SaveConfig(paths, cfg); err != nil {
		t.Fatalf("save config: %v", err)
	}

	machine, err := state.LoadMachine(paths, "lumen-test-host")
	if err != nil {
		t.Fatalf("load machine: %v", err)
	}
	if len(machine.Repos) != 1 {
		t.Fatalf("machine repo count = %d, want 1", len(machine.Repos))
	}
	machine.Repos[0].OriginURL = ""
	machine.Repos[0].Upstream = ""
	machine.Repos[0].HasDirtyTracked = true
	machine.Repos[0].HasUntracked = false
	machine.Repos[0].StateHash = domain.ComputeStateHash(machine.Repos[0])
	if err := state.SaveMachine(paths, machine); err != nil {
		t.Fatalf("save machine: %v", err)
	}

	app.LookPath = func(file string) (string, error) {
		if file != "lumen" {
			t.Fatalf("lookPath file = %q, want lumen", file)
		}
		return "/usr/local/bin/lumen", nil
	}
	draftCalls := 0
	app.RunCommandInDir = func(dir string, name string, args ...string) (string, error) {
		if dir != repoPath {
			t.Fatalf("run dir = %q, want %q", dir, repoPath)
		}
		if name != "/usr/local/bin/lumen" {
			t.Fatalf("run binary = %q, want %q", name, "/usr/local/bin/lumen")
		}
		if len(args) != 1 || args[0] != "draft" {
			t.Fatalf("run args = %v, want [draft]", args)
		}
		draftCalls++
		return "feat: generated by lumen default\n", nil
	}

	if err := os.WriteFile(filepath.Join(repoPath, "work.txt"), []byte("change\n"), 0o644); err != nil {
		t.Fatalf("write changed file: %v", err)
	}

	code, err := app.runFix(FixOptions{
		Project:   "api",
		Action:    FixActionStageCommitPush,
		NoRefresh: true,
	})
	if err != nil {
		t.Fatalf("runFix error: %v", err)
	}
	if code != 1 {
		t.Fatalf("runFix code = %d, want 1 (repo remains unsyncable without origin)", code)
	}
	if draftCalls != 1 {
		t.Fatalf("lumen draft calls = %d, want 1", draftCalls)
	}

	subjectOut, err := app.Git.RunGit(repoPath, "log", "-1", "--pretty=%s")
	if err != nil {
		t.Fatalf("git log failed: %v", err)
	}
	if got := strings.TrimSpace(subjectOut); got != "feat: generated by lumen default" {
		t.Fatalf("commit subject = %q, want %q", got, "feat: generated by lumen default")
	}
}

func newLumenTestApp(t *testing.T) (*App, state.Paths, string) {
	t.Helper()

	paths := state.NewPaths(t.TempDir())
	now := time.Date(2026, time.February, 16, 12, 0, 0, 0, time.UTC)

	app := New(paths, io.Discard, io.Discard)
	app.SetVerbose(false)
	app.Hostname = func() (string, error) { return "lumen-test-host", nil }
	app.Now = func() time.Time { return now }

	cfg := state.DefaultConfig()
	cfg.GitHub.Owner = "alice"
	if err := state.SaveConfig(paths, cfg); err != nil {
		t.Fatalf("save config: %v", err)
	}

	repoPath := filepath.Join(paths.Home, "software", "api")
	if err := os.MkdirAll(repoPath, 0o755); err != nil {
		t.Fatalf("mkdir repo: %v", err)
	}
	if err := app.Git.InitRepo(repoPath); err != nil {
		t.Fatalf("git init: %v", err)
	}

	machine := state.BootstrapMachine("lumen-test-host", "lumen-test-host", now)
	machine.DefaultCatalog = "software"
	machine.Catalogs = []domain.Catalog{{Name: "software", Root: filepath.Join(paths.Home, "software")}}
	machine.LastScanAt = now
	machine.UpdatedAt = now
	rec := domain.MachineRepoRecord{
		RepoKey:   "software/api",
		Name:      "api",
		Catalog:   "software",
		Path:      repoPath,
		OriginURL: "https://github.com/alice/api.git",
		Branch:    "main",
		Syncable:  true,
	}
	rec.StateHash = domain.ComputeStateHash(rec)
	machine.Repos = []domain.MachineRepoRecord{rec}
	if err := state.SaveMachine(paths, machine); err != nil {
		t.Fatalf("save machine: %v", err)
	}

	return app, paths, repoPath
}
